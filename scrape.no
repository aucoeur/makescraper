// package scrapey

// import (
// 	"context"
// 	"fmt"
// 	"log"
// 	"os"

// 	"github.com/chromedp/cdproto/cdp"
// 	"github.com/chromedp/chromedp"
// )

// func throwError(err error) {
// 	if err != nil {
// 		log.Fatal(err)
// 	}
// }

// // writeToFile saves array to txt, currently overwrites
// func writeToFile(link string) {
// 	// If file doesn't exist, create, else append to it
// 	file, err := os.OpenFile("links.txt", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
// 	throwError(err)

// 	defer file.Close()

// 	if _, err := file.WriteString(link); err != nil {
// 		file.Close()
// 		throwError(err)
// 	}

// 	fmt.Println("file saved")
// }

// // https://github.com/chromedp/examples/blob/master/click2/main.go
// func main() {
// 	// Create new chrome instance
// 	fmt.Println("creating chrome instance")
// 	ctx, cancel := chromedp.NewContext(
// 		context.Background(),
// 		chromedp.WithLogf(log.Printf),
// 	)
// 	defer cancel()
// 	// Create a timeout
// 	// ctx, cancel = context.WithTimeout(ctx, 45*time.Second)
// 	// defer cancel()

// 	var nodes []*cdp.Node

// 	// var link string

// 	err := chromedp.Run(ctx,
// 		// Navigate to the URL
// 		chromedp.Navigate(`https://leetcode.com/problemset/all/`),

// 		// Wait until an important part is of the page visible (the element data that we need)
// 		chromedp.WaitVisible(`.reactable-pagination`),
// 		chromedp.WaitReady(`.reactable-data`),

// 		// Scrape the important data (the element text)
// 		chromedp.Nodes(`td[label='Title'] > div > a:only-child`, &nodes, chromedp.ByQuery),
// 	)
// 	throwError(err)

// 	for _, node := range nodes {
// 		writeToFile(node.AttributeValue("href"))
// 	}

// }
